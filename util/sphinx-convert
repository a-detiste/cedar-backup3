#!/bin/bash
# vim: set ft=sh:
# Automate conversion from Epytext format to Sphinx reStructuredText using the Google comment standard

# MOTIVATIONS
#
# I have been using Epydoc for a long time to automatically generate API
# documentation.  It works well, and I've been happy with it.  Unfortunately,
# it requires the Python 2 interpreter.  That makes it sort of iffy to use with
# Python 3 code, and will also eventually be a problem when Python 2 hits its
# end of life in 2020.  
#
# I've looked at converting the Epydoc code to run under Python 3, but it's a
# fairly large undertaking and I haven't been very successful at it.  Most of
# the code converts pretty easily, but some modules do lot of text processing.
# Making sure that code work in a backwards-compatible way has proved
# challenging due to the Python 3 unicode change.
#
# Bottom line: I need an alternative that requires less work.  Also, since I
# maintain the Epydoc packages for Debian, I want to be able to suggest an
# alternative, at least to the other Debian maintainers that use Epydoc as a
# build dependency.
#
# GOALS
#
# My goal is to convert from Epytext-style docstrings to Google-style
# docstrings.  Google's docstring standard is documented here:
#
#   http://google.github.io/styleguide/pyguide.html#Comments
#
# After some research, I've decided that the Sphinx tool is probably the best
# way to do this.  The way to do Google docstrings with Sphinx is to use the
# Napolean plugin:
#
#   http://www.sphinx-doc.org/en/stable/ext/napoleon.html
#
# The resulting documentation is not as pretty as Epydoc, but it's legible.
#
# PROCESS NOTES
#
# My first step was to install the python3-sphinx package, which includes all
# of the necessary tools.  Then, I generated initial Sphinx configuration with
# something like this:
#
#   sphinx-apidoc -f -H "Cedar Backup" -V "3" -R "x.y.z" -A "Kenneth J.  Pronovici" -F -o sphinx CedarBackup3
#
# I ran the Sphinx 'make html' build target, looked at the output, and adjusted
# conf.py and the various .rst files by hand until I was generally happy with
# the layout, titles, etc.  
#
# To make Sphinx include my constructor documentation, I had to manually add
# the following to every automodule section in the .rst files:
#
#   :special-members: __init__
#
# Next, I fixed the various warnings that Sphinx found in the code in its
# original form.  These were generally pretty simple.  For instance, Sphinx
# doesn't like reStructuredText headings within docstrings for functions or
# methods, so I converted those manually to a different form.
#
# Then, I did a mass conversion of the entire codebase like this:
#
#   util/sphinx-convert $(find CedarBackup3 -name "*.py")
#
# The rules below got the code most of the way to a working state.  I still had
# to fix a few things by hand to eliminate warnings.  For instance, there
# sometimes needs to be a blank like above a Raises: block, which wasn't there
# in all places.  The other big problem was that Sphinx wasn't always able to
# find cross-references that I created based on L{}, so I usually just
# converted those to embedded literals instead.  And, Sphinx doesn't seem to
# like nested parenthesis within a parameter type definition.  

# Definitions
PERL="perl -pi"
MULTILINE="-0777"   # This piece of Perl voodoo gets us true multiline processing

# Remove periods and trailing whitespace from the end of various kinds of statements, to make things easier later
$PERL -e 's|(((\@param)\|(\@type)\|(\@return)\|(\@raise)\|(\@var)\|(\@[ic]var))(.*?))([. ]*$)|${1}|g' "$@"

# Simple single-line tags
$PERL -e 's|(C\{)(.*?)(\})|``${2}``|g' "$@"
$PERL -e 's|(I\{)(.*?)(\})|*${2}*|g' "$@"
$PERL -e 's|(B\{)(.*?)(\})|**${2}**|g' "$@"
$PERL -e 's|(L\{)(.*?)(\(\))?(\})|:any:`${2}`|g' "$@"
$PERL -e 's|(\@note:)|*Note:*|g' "$@"
$PERL -e 's|(\@author:)|:author:|g' "$@"
$PERL -e 's|\@returns:|\@return:|g' "$@"
$PERL -e 's|(^\s+)(\@return:)(.*$)|${1}Returns:\n${1}   ${3}|g' "$@"

# @sort statements get removed because they have no meaning any more
# These are a little tricky because they can extend to several lines
$PERL $MULTILINE -e 's|(\@sort: )([a-zA-Z0-9_, ]*)(\n\s*[a-zA-Z0-9_, ]*)*||gm' "$@"

# @raise statements
# We need to turn multiple @raise statements into a single Raises block
$PERL $MULTILINE -e 's|((\n)([^\n]*))((\@raise )(.*?)(: )(.*)((\n(\s+)(\@raise )(.*?)(: )(.*))*))|\n${3}Raises:\n${3}${4}|gm' "$@"
$PERL -e 's|(\s+)(\@raise )(.*)|${1}   ${3}|g' "$@"

# Simple @param statements
# We need to turn multiple @param statements into a single Args block
# We also need to handle the possibility of an optional @type statement
$PERL $MULTILINE -e 's|(\@param )(.*)(: )(.*)(\n\s+)(\@type )(.*)(: )(.*)(\n\s*\n)?|${1}${2} (${9}): ${4}\n|gm' "$@"
$PERL $MULTILINE -e 's|((\n)([^\n]*))((\@param )(.*?)(: )(.*)((\n(\s+)(\@param )(.*?)(: )(.*))*))|\n${3}Args:\n${3}${4}|gm' "$@"
$PERL -e 's|(\s+)(\@param )(.*)|${1}   ${3}|g' "$@"

# @var statements
# We need to turn multiple @var statements into a single Attributes block
$PERL $MULTILINE -e 's|((\@var )(.*)(: )(.*)((\n(\@var )(.*?)(: )(.*))*))|Module Attributes\n=================\n\nAttributes:\n${1}|gm' "$@"
$PERL -e 's|(\@var )(.*)|   ${2}|g' "$@"

# @cvar and @ivar statements
# We need to turn multiple @cvar or @ivar statements into a single Attributes block
$PERL $MULTILINE -e 's|((\n)([^\n]*))((\@[ci]var )(.*?)(: )(.*)((\n(\s+)(\@[ci]var )(.*?)(: )(.*))*))|\n${3}Attributes:\n${3}${4}|gm' "$@"
$PERL -e 's|(\s+)(\@[ci]var )(.*)|${1}   ${3}|g' "$@"

